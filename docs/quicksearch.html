<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"jsoncache.js.html":{"id":"jsoncache.js.html","title":"Source: jsoncache.js","body":" json-fetch-cache Classes JSONCache Source: jsoncache.js 'use strict'; const EventEmitter = require('events'); const retryCodes = [429].concat((process.env.JSON_CACHE_RETRY_CODES || '') .split(',').map(code =&gt; parseInt(code.trim(), 10))); const defaultOpts = { parser: JSON.parse, promiseLib: Promise, logger: console, delayStart: false, opts: {}, maxListeners: 10, useEmitter: false, maxRetry: 1, integrity: () =&gt; true, }; class JSONCache extends EventEmitter { /** * Make a new cache * @param {string} url url to fetch * @param {number} [timeout=60000] optional timeout * @param {Object} options Options object * @param {function} options.parser optional parser to parse data. defaults to JSON.parse * @param {Class} options.promiseLib optional promise library override * @param {Object} options.logger optional Logger * @param {boolean} options.delayStart whether or not to delay starting updating the cache * until start is requested * @param {Object} options.opts options to pass to the parser * @param {number} options.maxListeners maximum listeners * (only applicable if leveraging emitter) * @param {boolean} options.useEmitter whether or not to use the optional node emitter * @param {number} options.maxRetry maximum number of attempts to retry getting data * @param {function} options.integrity optional function to check if the data is worth keeping */ constructor(url, timeout, options) { super(); // eslint-disable-next-line no-param-reassign options = { ...defaultOpts, ...options, }; const { parser, promiseLib, logger, delayStart, opts, maxListeners, useEmitter, maxRetry, integrity, } = options; this.url = url; // eslint-disable-next-line global-require this.protocol = this.url.startsWith('https') ? require('https') : require('http'); this.maxRetry = maxRetry; this.timeout = timeout || 60000; this.currentData = null; this.updating = null; this.Promise = promiseLib; this.parser = parser; this.hash = null; this.logger = logger; this.delayStart = delayStart; this.opts = opts; this.useEmitter = useEmitter; this.integrity = integrity; if (useEmitter) { this.setMaxListeners(maxListeners); } if (!delayStart) { this.startUpdating(); } } getData() { if (this.delayStart &amp;&amp; !this.currentData &amp;&amp; !this.updating) { this.startUpdating(); } if (this.updating) { return this.updating; } return this.Promise.resolve(this.currentData); } getDataJson() { return this.getData(); } update() { this.updating = this.httpGet().then(async (data) =&gt; { const parsed = this.parser(data, this.opts); if (!this.integrity(parsed)) return this.currentData; // data passed integrity check this.currentData = parsed; if (this.useEmitter) { setTimeout(async () =&gt; this.emit('update', await this.currentData), 2000); } this.updating = null; return this.currentData; }).catch((err) =&gt; { this.updating = null; throw err; }); } httpGet() { return new this.Promise((resolve) =&gt; { const request = this.protocol.get(this.url, (response) =&gt; { this.logger.debug(`beginning request to ${this.url}`); const body = []; if (response.statusCode &lt; 200 || response.statusCode &gt; 299) { if ((response.statusCode &gt; 499 || retryCodes.includes(response.statusCode)) &amp;&amp; this.retryCount &lt; this.maxRetry) { this.retryCount += 1; setTimeout(() =&gt; this.httpGet().then(resolve).catch(this.logger.error), 1000); } else { this.logger.error(`${response.statusCode}: Failed to load ${this.url}`); resolve('[]'); } } else { response.on('data', chunk =&gt; body.push(chunk)); response.on('end', () =&gt; { this.retryCount = 0; resolve(body.join('')); }); } }); request.on('error', (err) =&gt; { this.logger.error(`${err.statusCode}: ${this.url}`); resolve('[]'); }); }); } startUpdating() { this.updateInterval = setInterval(() =&gt; this.update(), this.timeout); this.update(); } stop() { clearInterval(this.updateInterval); } stopUpdating() { this.stop(); } } module.exports = JSONCache; × Search results Close Documentation generated by JSDoc 3.6.3 on Sunday, July 19th 2020, 21:04:02 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" json-fetch-cache Classes JSONCache Classes Classes JSONCache × Search results Close Documentation generated by JSDoc 3.6.3 on Sunday, July 19th 2020, 21:04:02 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" json-fetch-cache Classes JSONCache json-fetch-cache A simple package for fetching JSON from a URL and caching it for a decided amount of time. Documentation Installation $ npm i -S json-fetch-cache Usage const Cache = require('json-fetch-cache'); const pcCache = new Cache('http://content.warframe.com/dynamic/worldState.php', 10000); pcCache.getData() .then((data) =&gt; { console.log(data); process.exit(0); }) .catch((error)=&gt;{ console.error(error); }); × Search results Close Documentation generated by JSDoc 3.6.3 on Sunday, July 19th 2020, 21:04:02 using the DocStrap template. "},"JSONCache.html":{"id":"JSONCache.html","title":"Class: JSONCache","body":" json-fetch-cache Classes JSONCache Class: JSONCache JSONCache new JSONCache(url [, timeout], options) Make a new cache Parameters: Name Type Argument Default Description url string url to fetch timeout number &lt;optional&gt; 60000 optional timeout options Object Options object Properties Name Type Description parser function optional parser to parse data. defaults to JSON.parse promiseLib Class optional promise library override logger Object optional Logger delayStart boolean whether or not to delay starting updating the cache until start is requested opts Object options to pass to the parser maxListeners number maximum listeners (only applicable if leveraging emitter) useEmitter boolean whether or not to use the optional node emitter maxRetry number maximum number of attempts to retry getting data integrity function optional function to check if the data is worth keeping Source: jsoncache.js, line 38 × Search results Close Documentation generated by JSDoc 3.6.3 on Sunday, July 19th 2020, 21:04:02 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
